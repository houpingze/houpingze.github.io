<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://houpingze.github.io</id>
    <title>houpingzeAKIOI</title>
    <updated>2020-08-11T12:08:00.470Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://houpingze.github.io"/>
    <link rel="self" href="https://houpingze.github.io/atom.xml"/>
    <subtitle>温故而知新，可以AKIOI
hiahiahia</subtitle>
    <logo>https://houpingze.github.io/images/avatar.png</logo>
    <icon>https://houpingze.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, houpingzeAKIOI</rights>
    <entry>
        <title type="html"><![CDATA[3916高难度补充]]></title>
        <id>https://houpingze.github.io/3916-gao-nan-du-bu-chong/</id>
        <link href="https://houpingze.github.io/3916-gao-nan-du-bu-chong/">
        </link>
        <updated>2020-08-09T03:57:08.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://houpingze.github.io/post-images/1596945482668.png" alt="" loading="lazy">😀😀😀😀😀😀😀</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
typedef unsigned long long ull;
using namespace std;
int n,cnt,m;
int a[15],f[100000];
int main(){
	for(int i=1;i&lt;=10;i++) cin&gt;&gt;a[i];
	cin&gt;&gt;n;
	/*
	f[i]表示i公里的最优解 
	*/ 
    memset(f,0x7f,sizeof(f));
	f[1]=a[1];
	for(int i=2;i&lt;=n;i++){
		f[i]=f[i-1]+a[1];
		for(int j=1;j&lt;=min(i,10);j++){
	 		f[i]=min(f[i],a[j]+f[i-j]);
		}
	}
	cout&lt;&lt;f[n];
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[高精度]]></title>
        <id>https://houpingze.github.io/gao-jing-du/</id>
        <link href="https://houpingze.github.io/gao-jing-du/">
        </link>
        <updated>2020-08-09T02:22:21.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://houpingze.github.io/post-images/1596939794090.png" alt="" loading="lazy"></figure>
<h1 id="使用高精度的步骤">使用高精度的步骤：</h1>
<ol>
<li>利用string进行读入</li>
<li>将string存入数组中，数字的低位放在数组的前面，高位放在数组后面</li>
<li>利用数组进行运算</li>
<li>输出结果</li>
<li><img src="https://houpingze.github.io/post-images/1596940661406.png" alt="" loading="lazy"><br>
代码如下：<pre><code class="language-cpp">    a[0]=x.size();
 for(int i=1;i&lt;=a[0];i++){
 	a[i]=x[a[0]-i]-'0';
 } 
 b[0]=y.size();
 for(int i=1;i&lt;=b[0];i++){
 	b[i]=y[b[0]-i]-'0';
 } 
 
</code></pre>
</li>
</ol>
<h2 id="代码">代码：</h2>
<h3 id="加">加</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
string x,y;
int a[10000],b[10000],c[100000];
int main(){
    cin&gt;&gt;x&gt;&gt;y;
    /* s1-&gt;a */
    /*低位放在下标少的*/
    a[0]=x.size();
    for(int i=1;i&lt;=a[0];i++){
    	a[i]=x[a[0]-i]-'0';
	} 
    b[0]=y.size();
    for(int i=1;i&lt;=b[0];i++){
    	b[i]=y[b[0]-i]-'0';
	} 
	int l=max(a[0],b[0]),len=0;
	for(int i=1;i&lt;=l;i++){
		c[i]+=a[i]+b[i];
		len=max(len,i);
		if(c[i]&gt;=10){
			c[i]-=10;
			c[i+1]++;
			len=i+1;
		}
	}
	for(int i=len;i&gt;=1;i--) cout&lt;&lt;c[i];
    return 0;
}
</code></pre>
<p>老师的代码（其实差不多）：<br>
<img src="https://houpingze.github.io/post-images/1596941687551.png" alt="" loading="lazy"></p>
<h3 id="减">减</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
string x,y;
int a[10000],b[10000],c[100000];
int main(){
    cin&gt;&gt;x&gt;&gt;y;
    a[0]=x.size(),b[0]=y.size();
    for(int i=1;i&lt;=a[0];i++) a[i]=x[a[0]-i]-'0'; 
    for(int i=1;i&lt;=b[0];i++) b[i]=y[b[0]-i]-'0'; 
	int l=max(a[0],b[0]),len=0;
	for(int i=1;i&lt;=l;i++){
		if(a[i]&lt;b[i]) a[i]+=10,a[i+1]--;
		c[i]=a[i]-b[i]; 
	}
	while(l&gt;0&amp;&amp;c[l]==0) l--;
	for(int i=l;i&gt;=1;i--) cout&lt;&lt;c[i];
    return 0;
}
</code></pre>
<p>课后测：<br>
<img src="https://houpingze.github.io/post-images/1596946748131.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[4507 补充]]></title>
        <id>https://houpingze.github.io/4507-bu-chong/</id>
        <link href="https://houpingze.github.io/4507-bu-chong/">
        </link>
        <updated>2020-08-08T03:41:36.000Z</updated>
        <content type="html"><![CDATA[<p>1.填表法<br>
2.刷表法</p>
<h1 id="刷表法">刷表法</h1>
<p>代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int n,cnt,m,f[100][100],x,y;
int dir[4][5]{{-2,1},{2,1},{-1,2},{1,2}};
int main(){
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y;
    swap(n,m);
	f[0][0]=1;
	for(int j=0;j&lt;=n;j++){
		for(int i=0;i&lt;=m;i++){
			if(i==x||j==y){
				f[i][j]=0;
				continue;
			}
			for(int k=0;k&lt;4;k++){
				int nx=i+dir[k][0],ny=j+dir[k][1];
				if(nx&gt;=0&amp;&amp;nx&lt;=m&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;=n) f[nx][ny]+=f[i][j];
			}
		} 
	}
	cout&lt;&lt;f[m][n];
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[其他递推]]></title>
        <id>https://houpingze.github.io/qi-ta-di-tui/</id>
        <link href="https://houpingze.github.io/qi-ta-di-tui/">
        </link>
        <updated>2020-08-08T02:46:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="4514">4514</h2>
<p><img src="https://houpingze.github.io/post-images/1596855149009.png" alt="" loading="lazy"><br>
f[i]表示i个椭圆最多可以把平面分成f[i]个地盘<br>
<em><em>递推式：f[i]=f[i-1]+2</em>(i-1)(其中i-1表示前i-1个椭圆，2表示第i个椭圆会和每个椭圆相交2次，每相交一次会产生1个新的地盘)</em>*<br>
边界：f[1]=2<br>
解：f[n]<br>
代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
typedef unsigned long long ull;
using namespace std;
int n,cnt,m;
int main(){
	cin&gt;&gt;n;
	int f[26];
	f[1]=2;
	for(int i=2;i&lt;=n;i++){
		f[i]=f[i-1]+2*(i-1);
	} 
	cout&lt;&lt;f[n];
}
</code></pre>
<h2 id="4515">4515</h2>
<p>小P最近搬进了新家，打算布置一番。现在小P有n本不同的书，想放进带有m个格子的书架上（m&lt;n）。要求每个格子至少有一本书。请你帮小P计算有多少种布置的方案。</p>
<p>定义：f[i][j]表示前i本书放入j个格子的方案总数,（每个格子至少放1本书）<br>
递推式：f[i][j]=f[i-1][j]*j+f[i-1][j-1]<br>
边界：f[1][1]=1;<br>
解：f[n][m]</p>
<p>代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
typedef unsigned long long ull;
using namespace std;
int n,cnt,m,f[100][100];
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	f[1][1]=1;
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=m;j++){
			if(i==1&amp;&amp;j==1) continue;
			f[i][j]=f[i-1][j]*j+f[i-1][j-1];
		}
	}
	cout&lt;&lt;f[n][m];
}

</code></pre>
<p>课后测：<br>
<img src="https://houpingze.github.io/post-images/1596860600158.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[暑假第11次课 过河卒]]></title>
        <id>https://houpingze.github.io/shu-jia-di-11-ci-ke-guo-he-zu/</id>
        <link href="https://houpingze.github.io/shu-jia-di-11-ci-ke-guo-he-zu/">
        </link>
        <updated>2020-08-06T02:09:10.000Z</updated>
        <content type="html"><![CDATA[<p>课前测：<br>
<img src="https://houpingze.github.io/post-images/1596680370312.png" alt="" loading="lazy"></p>
<p>重点：<br>
数塔问题中，如果自上而下推导，目标是什么？<br>
答：         max{f[n][i]}, i∈[1,n];<br>
笔记：</p>
<h2 id="递推过河卒">递推（过河卒）</h2>
<p>f[i][j]表示从起点到点（i，j）的方案总数<br>
f[i][j]=f[i-1][j]+f[i][j-1];(如果（i，j)是马🐎的控制点，那么f[i][j]=0)<br>
边界：f[1][1]=1;<br>
解：f[m][n]</p>
<h2 id="代码">代码</h2>
<h3 id="4391">4391:</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;map&gt;
typedef unsigned long long ull;
using namespace std;
int n,cnt,m,x,y;
map&lt;int,map&lt;int,int&gt; &gt;ma,f;
int main(){
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y;
//	swap(x,y);
	ma[x+2][y+1]=1;
	ma[x+1][y+2]=1;
	ma[x-1][y+2]=1;
	ma[x-2][y+1]=1;
	ma[x+2][y-1]=1;
	ma[x+1][y-2]=1;
	ma[x-1][y-2]=1;
	ma[x-2][y-1]=1;
	ma[x][y]=1;
	f[0][0]=1;
	for(int i=0;i&lt;=n;i++){
		for(int j=0;j&lt;=m;j++){
			if(i==0&amp;&amp;j==0) continue;
			if(i==0) f[i][j]=f[i][j-1];
			else if(j==0) f[i][j]=f[i-1][j];
			else f[i][j]=f[i-1][j]+f[i][j-1];
			f[i][j]*=(ma[i][j]==0);
		}
	}
	cout&lt;&lt;f[n][m];
}

</code></pre>
<p>老师的方法：<br>
定义一个方向数组，表示马走的方向，其他都一样</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
typedef unsigned long long ull;
using namespace std;
int n,cnt,m,x,y;
bool b[50][50];
const int dir[8][2]={
	{-1,-2},{-1,2},{1,-2},{1,2},
	{2,-1},{2,1},{-2,-1},{-2,1}
};
int f[100][100];
int main(){
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y;
	b[x][y]=1;
	for(int i=0;i&lt;8;i++){
		int nx=x+dir[i][0],ny=y+dir[i][1];
		if(nx&gt;=0&amp;&amp;ny&gt;=0) b[nx][ny]=1;
	} 
	f[0][0]=1;
	for(int i=0;i&lt;=n;i++){
		for(int j=0;j&lt;=m;j++){
			if(i==0&amp;&amp;j==0||b[i][j]) continue;
			if(i-1&gt;=0) f[i][j]=f[i-1][j];
			if(j-1&gt;=0) f[i][j]+=f[i][j-1]; 
		}
	}
//	if(b[0][0]) cout&lt;&lt;0;
	cout&lt;&lt;f[n][m];
}
</code></pre>
<h3 id="5100">5100:</h3>
<p>f[i][j]表示从起点跳到点(i,j)的方案总数<br>
f[i][j]=f[i-2][j-1]+f[i-1]<a href="%E8%BD%A6%F0%9F%9A%97%E8%A6%86%E7%9B%96%E7%9A%84%E4%BD%8D%E7%BD%AE%E4%B8%BA0">j-2</a><br>
边界：f[0][0]=1<br>
解：f[n][m]</p>
<p>代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;map&gt;
typedef unsigned long long ull;
using namespace std;
int n,cnt,m,x,y;
map&lt;ull , map&lt;ull,ull&gt; &gt;f,ju;
int main(){
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y;
	f[0][0]=1;
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=m;j++){
			if(i!=x&amp;&amp;j!=y) f[i][j]=f[i-2][j-1]+f[i-1][j-2];
		} 
	}
	cout&lt;&lt;f[n][m];
}

</code></pre>
<p>课后测：<br>
<img src="https://houpingze.github.io/post-images/1596687726558.png" alt="" loading="lazy"></p>
<p>重点：注意dir数组</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://houpingze.github.io/hello-gridea/</id>
        <link href="https://houpingze.github.io/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>