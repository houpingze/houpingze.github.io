<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://houpingze.github.io</id>
    <title>houpingzeAKIOI</title>
    <updated>2020-09-26T01:58:59.629Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://houpingze.github.io"/>
    <link rel="self" href="https://houpingze.github.io/atom.xml"/>
    <subtitle>温故而知新，可以AKIOI
hiahiahia</subtitle>
    <logo>https://houpingze.github.io/images/avatar.png</logo>
    <icon>https://houpingze.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, houpingzeAKIOI</rights>
    <entry>
        <title type="html"><![CDATA[搬迁]]></title>
        <id>https://houpingze.github.io/ban-qian/</id>
        <link href="https://houpingze.github.io/ban-qian/">
        </link>
        <updated>2020-09-26T01:43:41.000Z</updated>
        <content type="html"><![CDATA[<p>houpingze.cf</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[递归基本思想]]></title>
        <id>https://houpingze.github.io/ak-ctsc-1/</id>
        <link href="https://houpingze.github.io/ak-ctsc-1/">
        </link>
        <updated>2020-09-05T02:15:54.000Z</updated>
        <summary type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://houpingze.github.io/post-images/1599272172797.png" alt="" loading="lazy"></figure>
<h2 id="递归的两大要素">递归的两大要素：</h2>
<h3 id="递推关系">递推关系：</h3>
<p>根据某种方法，对问题进行拆分【递】</p>
<h3 id="终止条件">终止条件：</h3>
<p>到达某种条件，问题可以直接求解，此时到达递归的边界，然后依次组合出原来的大问题的解。【归】</p>
<h2 id="代码讲解">代码讲解：</h2>
<p>2404：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int f(int n){
    if(n==1) return 1;
    return f(n-1)+n;
}
int main(){
    int n;
    cin &gt;&gt; n;
    cout&lt;&lt;f(n);
}
 
</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>表示前n个数的和<br>
递推关系：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>+</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">f(n)=f(n-1)+n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span><br>
边界:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(1)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p>2462:</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
typedef unsigned long long ull;
using namespace std;
int n,cnt,m,a[100000];
int f(int n){
	if(n==1) return a[1];
	return max(f(n-1),a[n]);
}
int main(){
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];
	cout&lt;&lt;f(n);
}

</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>表示前n个数的最大值<br>
递推：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>max</mi><mo>⁡</mo><mo>(</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo separator="true">,</mo><mi>a</mi><mo>[</mo><mi>n</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)=\max(f(n-1),a[n])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span><br>
边界：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo>=</mo><mi>a</mi><mo>[</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">f(1)=a[1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p>
<h2 id="斐波那契数列">斐波那契数列：</h2>
<p>普通算法：</p>
<pre><code>int f(int n){
  if(n==1||n==2) return 1;
  return f(n-1)+f(n-2)
}
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://houpingze.github.io/post-images/1599272172797.png" alt="" loading="lazy"></figure>
<h2 id="递归的两大要素">递归的两大要素：</h2>
<h3 id="递推关系">递推关系：</h3>
<p>根据某种方法，对问题进行拆分【递】</p>
<h3 id="终止条件">终止条件：</h3>
<p>到达某种条件，问题可以直接求解，此时到达递归的边界，然后依次组合出原来的大问题的解。【归】</p>
<h2 id="代码讲解">代码讲解：</h2>
<p>2404：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int f(int n){
    if(n==1) return 1;
    return f(n-1)+n;
}
int main(){
    int n;
    cin &gt;&gt; n;
    cout&lt;&lt;f(n);
}
 
</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>表示前n个数的和<br>
递推关系：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>+</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">f(n)=f(n-1)+n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span><br>
边界:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(1)=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
<p>2462:</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
typedef unsigned long long ull;
using namespace std;
int n,cnt,m,a[100000];
int f(int n){
	if(n==1) return a[1];
	return max(f(n-1),a[n]);
}
int main(){
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];
	cout&lt;&lt;f(n);
}

</code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>表示前n个数的最大值<br>
递推：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo>=</mo><mi>max</mi><mo>⁡</mo><mo>(</mo><mi>f</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo separator="true">,</mo><mi>a</mi><mo>[</mo><mi>n</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)=\max(f(n-1),a[n])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span><br>
边界：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo>=</mo><mi>a</mi><mo>[</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">f(1)=a[1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span></span></span></span></p>
<h2 id="斐波那契数列">斐波那契数列：</h2>
<p>普通算法：</p>
<pre><code>int f(int n){
  if(n==1||n==2) return 1;
  return f(n-1)+f(n-2)
}
</code></pre>
<!-- more -->
<p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>but,why???<br>
because :</p>
<h2 id=""><img src="https://cdn.jsdelivr.net/gh/houpingze/tc@latest/data/20200905112551.png" alt="" loading="lazy"></h2>
<h2 id="递归过程中有大量的重复计算例如上图fn-2被算了很多次">递归过程中有大量的重复计算，例如上图f(n-2)被算了很多次。</h2>
<hr>
<p>我们可以通过记忆化来避免重复计算，即定义一个数组存。<br>
记忆化：</p>
<pre><code>int f(int n){
  if(j[n]!=0) return j[n];
  if(n==1||n==2) return 1;
  j[n]=f(n-1)+f(n-2);
  return f(n-1)+f(n-2)
}
</code></pre>
<p>2458:<br>
题目：<br>
<img src="https://cdn.jsdelivr.net/gh/houpingze/tc@latest/data/20200905114616.png" alt="" loading="lazy"></p>
<p><code>f(n)</code>表示数字 n 各个位数上的和</p>
<p>递推： <code>f(n)=f(n/10)+n%10</code></p>
<p>边界：</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">n&gt;10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>时 <code>return n;</code></p>
<p>代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
typedef unsigned long long ull;
using namespace std;
int n,cnt,m,a[100000];
int f(int n){
	if(n&lt;10) return n;
	return f(n/10)+n%10;
}
int main(){
	cin&gt;&gt;n; 
	cout&lt;&lt;f(n);
}

</code></pre>
<p>3831:</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
typedef unsigned long long ull;
using namespace std;
int n,cnt,m;
string s;
bool f(int i){
	if(i==s.size()/2) return true;
	if(s[i]!=s[s.size()-1-i]) return false;
	return f(i+1); 
}
int main(){
	cin&gt;&gt;s; 
	if(f(0)==1) cout&lt;&lt;&quot;是回文串&quot;;
	else cout&lt;&lt;&quot;不是回文串&quot;; 
}

</code></pre>
<p>我的代码：<br>
f(i)表示s[i]~s[s.size()-1-i]是否是回文<br>
递推：</p>
<p><code>if(i==s.size()/2) return true;</code><br>
<code>if(s[i]!=s[s.size()-1-i]) return false;</code><br>
边界：</p>
<p><code>if(i==s.size()/2) return true;</code></p>
<pre><code>#include&lt;iostream&gt;
typedef unsigned long long ull;
using namespace std;
int n,cnt,m;
string s;
bool f(int i){
	if(i==s.size()/2) return true;
	if(s[i]!=s[s.size()-1-i]) return false;
	return f(i+1); 
}
int main(){
	cin&gt;&gt;s; 
	if(f(0)==1) cout&lt;&lt;&quot;是回文串&quot;;
	else cout&lt;&lt;&quot;不是回文串&quot;; 
}
</code></pre>
<p>老师的代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
typedef unsigned long long ull;
using namespace std;
int n,cnt,m;
string s;
bool f(int i,int j){
	if(i&gt;=j) return true;
	if(s[i]==s[j]) return f(i+1,j-1);
	return false;
}
int main(){
	cin&gt;&gt;s; 
	if(f(0,s.size()-1)==1) cout&lt;&lt;&quot;是回文串&quot;;
	else cout&lt;&lt;&quot;不是回文串&quot;; 
}

</code></pre>
<p>其实也差不多。。。<br>
<img src="https://cdn.jsdelivr.net/gh/houpingze/tc@latest/data/20200905121906.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[金牌冲刺6]]></title>
        <id>https://houpingze.github.io/hpz-uke-ioi/</id>
        <link href="https://houpingze.github.io/hpz-uke-ioi/">
        </link>
        <updated>2020-09-03T11:00:47.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://houpingze.github.io/post-images/1599130901935.png" alt="" loading="lazy"><br>
<img src="https://houpingze.github.io/post-images/1599131404879.png" alt="" loading="lazy"></p>
<p>/fad</p>
<h2 id="1183">1183:</h2>
<p>题目：<br>
聪明的卡卡西帮助工人师傅们解决了难题，师傅们为了表示感谢，带领他们到了附近的西瓜地，请他们吃西瓜，正好看到农民伯伯正在给每个西瓜称重，每个西瓜的重量都记录在纸上，农民伯伯想知道这遍地的西瓜哪个重量的西瓜最多。卡卡西眼前一亮，大声的说：伯伯，让我来帮你完成吧！</p>
<p>代码：</p>
<p>桶：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
typedef unsigned long long ull;
using namespace std;
int n,cnt,m,a[10001],t;
int main(){
    cin&gt;&gt;n;
    while(n--){
        cin&gt;&gt;t;
        a[t]++;	
    }
    for(int i=1;i&lt;=10000;i++){
        if(a[i]&gt;m){
            m=a[i];
            cnt=i;
        }
    }
    cout&lt;&lt;cnt;
}

</code></pre>
<p>暴力：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
typedef unsigned long long ull;
using namespace std;
int n,cnt,m,a[10001];
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a[i];
    }
    for(int i=1;i&lt;=10000;i++){
        int tmp=0;
        for(int j=1;j&lt;=n;j++){
            if(a[j]==i) tmp++;
        }
        if(m&lt;tmp){
            m=tmp;
            cnt=i;
        }
    }
    cout&lt;&lt;cnt;
}

</code></pre>
<h2 id="1350">1350</h2>
<p>题目：<br>
<img src="https://houpingze.github.io/post-images/1599134520033.png" alt="" loading="lazy"></p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
typedef unsigned long long ull;
using namespace std;
int n,cnt,m,a[100]{1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,4,1,2,3,1,2,3,4};
int main(){
	string s;
	getline(cin,s)
	;
	for(int i=0;i&lt;s.size();i++){
		if(s[i]!=' ') cnt+=a[s[i]-'a'];
		else cnt++;  
	} 
	cout&lt;&lt;cnt;
}

</code></pre>
<p>1631：</p>
<figure data-type="image" tabindex="1"><img src="https://houpingze.github.io/post-images/1599136671819.png" alt="" loading="lazy"></figure>
<p>代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
typedef unsigned long long ull;
using namespace std;
int n,cnt,m;
bool b[20000000];
int main(){
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++){
		double a;
		cin&gt;&gt;a&gt;&gt;m;
		for(int j=1;j&lt;=m;j++){
			b[(int)(a*j)]=!b[(int)(a*j)];
		}
	}
	for(int i=1;;i++){
		if(b[i]){
			cout&lt;&lt;i;
			return 0;
		}
	}
}

</code></pre>
<figure data-type="image" tabindex="2"><img src="https://houpingze.github.io/post-images/1599138922872.png" alt="" loading="lazy"></figure>
<p>😱😱😱😱😱😱😱😱😱😱😱😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥😥🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤😭😭🤐🤐🤐🤐😭😭😭😭😭😭😓😓😓😓😓😓😓😓😓😓😓😓😓😓😓😓😓😓😓😪😪😪😪😪😪😪😪😪😪😪😪😪😪😪😪😪😪😪😪😪😪😪😪😪😪😪😪😪😪😪😪😪😱😱😱😱😱😱😱😱😱😱😱😱😱😱😱😱😱😱😱😱😱😱😱😱😱😱😱😱😱😪😪😪😪😓😓😓😓😓😓😓😓😓😓😭😭😭😭😭🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤🤤</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[金牌冲刺6]]></title>
        <id>https://houpingze.github.io/jin-pai-chong-ci-6/</id>
        <link href="https://houpingze.github.io/jin-pai-chong-ci-6/">
        </link>
        <updated>2020-09-03T11:00:47.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://houpingze.github.io/post-images/1599130901935.png" alt="" loading="lazy"><br>
<img src="https://houpingze.github.io/post-images/1599131404879.png" alt="" loading="lazy"></p>
<p>/fad</p>
<h2 id="1183">1183:</h2>
<p>题目：<br>
聪明的卡卡西帮助工人师傅们解决了难题，师傅们为了表示感谢，带领他们到了附近的西瓜地，请他们吃西瓜，正好看到农民伯伯正在给每个西瓜称重，每个西瓜的重量都记录在纸上，农民伯伯想知道这遍地的西瓜哪个重量的西瓜最多。卡卡西眼前一亮，大声的说：伯伯，让我来帮你完成吧！</p>
<p>代码：</p>
<p>桶：</p>
<pre><code>#include&lt;iostream&gt;
typedef unsigned long long ull;
using namespace std;
int n,cnt,m,a[10001],t;
int main(){
    cin&gt;&gt;n;
    while(n--){
        cin&gt;&gt;t;
        a[t]++;	
    }
    for(int i=1;i&lt;=10000;i++){
        if(a[i]&gt;m){
            m=a[i];
            cnt=i;
        }
    }
    cout&lt;&lt;cnt;
}

</code></pre>
<p>暴力：</p>
<pre><code>#include&lt;iostream&gt;
typedef unsigned long long ull;
using namespace std;
int n,cnt,m,a[10001];
int main(){
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a[i];
    }
    for(int i=1;i&lt;=10000;i++){
        int tmp=0;
        for(int j=1;j&lt;=n;j++){
            if(a[j]==i) tmp++;
        }
        if(m&lt;tmp){
            m=tmp;
            cnt=i;
        }
    }
    cout&lt;&lt;cnt;
}

</code></pre>
<h2 id="1350">1350</h2>
<p>题目：<br>
<img src="https://houpingze.github.io/post-images/1599134520033.png" alt="" loading="lazy"></p>
<pre><code>#include&lt;iostream&gt;
typedef unsigned long long ull;
using namespace std;
int n,cnt,m,a[100]{1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,4,1,2,3,1,2,3,4};
int main(){
	string s;
	getline(cin,s)
	;
	for(int i=0;i&lt;s.size();i++){
		if(s[i]!=' ') cnt+=a[s[i]-'a'];
		else cnt++;  
	} 
	cout&lt;&lt;cnt;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c++入门（2）]]></title>
        <id>https://houpingze.github.io/cru-men-2/</id>
        <link href="https://houpingze.github.io/cru-men-2/">
        </link>
        <updated>2020-08-29T08:15:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="输入与输出部分">输入与输出部分</h1>
<p>我们先讲输出</p>
<p>要输出一个yes：</p>
<pre><code>cout&lt;&lt;&quot;yes&quot;;
</code></pre>
<p>要输出一个变量a：</p>
<pre><code>cout&lt;&lt;a;
</code></pre>
<p>要输出换行：</p>
<pre><code>cout&lt;&lt;endl;
</code></pre>
<h2 id="输入部分">输入部分</h2>
<p>我们要输入一个变量a：</p>
<pre><code>cin&gt;&gt;a;
</code></pre>
<p>带空格输入一个字符串s：</p>
<pre><code>getline(cin,s);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c++入门（1）]]></title>
        <id>https://houpingze.github.io/cru-men-1/</id>
        <link href="https://houpingze.github.io/cru-men-1/">
        </link>
        <updated>2020-08-29T07:48:42.000Z</updated>
        <content type="html"><![CDATA[<p>c++是一个编程语言</p>
<hr>
<p>我们初学者需要记得这个:</p>
<pre><code>#include&lt;iostream&gt; 
using namespace std; 
int main(){

}
--------------------------------
</code></pre>
<p>接下来我们来讲解一下这每一句</p>
<pre><code>#include&lt;iostream&gt;
</code></pre>
<p>加上这个语句，我们就可以在c++中输入输出东西，这个东西叫<strong>头文件</strong></p>
<pre><code>using namespace std;
</code></pre>
<p>这个语句的意思是使用名称空间</p>
<pre><code>int main(){

}
</code></pre>
<h2 id="这个语句的意思是主函数我们写主要代码就是在这里写的">这个语句的意思是主函数，我们写主要代码就是在这里写的</h2>
<h2 id="定义一个变量">定义一个变量：</h2>
<p>如果要定义一个整形变量a，需要这么做：</p>
<pre><code>int a;
</code></pre>
<p>注意，c++中每一条语句都需要加”；“</p>
<p>定义一个浮点型（小数）变量s：</p>
<pre><code>double s;
</code></pre>
<p>定义一个字符串a：</p>
<pre><code>string a;
</code></pre>
<p>定义一个整形数组：</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/houpingze/tc@latest/data/20200829161226.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[3916高难度补充]]></title>
        <id>https://houpingze.github.io/3916-gao-nan-du-bu-chong/</id>
        <link href="https://houpingze.github.io/3916-gao-nan-du-bu-chong/">
        </link>
        <updated>2020-08-09T03:57:08.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://houpingze.github.io/post-images/1596945482668.png" alt="" loading="lazy">😀😀😀😀😀😀😀</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
typedef unsigned long long ull;
using namespace std;
int n,cnt,m;
int a[15],f[100000];
int main(){
	for(int i=1;i&lt;=10;i++) cin&gt;&gt;a[i];
	cin&gt;&gt;n;
	/*
	f[i]表示i公里的最优解 
	*/ 
    memset(f,0x7f,sizeof(f));
	f[1]=a[1];
	for(int i=2;i&lt;=n;i++){
		f[i]=f[i-1]+a[1];
		for(int j=1;j&lt;=min(i,10);j++){
	 		f[i]=min(f[i],a[j]+f[i-j]);
		}
	}
	cout&lt;&lt;f[n];
}

</code></pre>
<figure data-type="image" tabindex="1"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACMAAAAqCAMAAAAOCBKjAAABjFBMVEUAAAAAAAAAAAAAAAAAAAAZGRkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHBwcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANDQ0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAAAAAAAAACAgLQ0NDe3t4AAAAAAAAAAAAAAAD///8BAQH4+PgzMzP39/cODg4REREICAjh4eHb29vOzs7IyMi4uLhzc3NjY2Pv7++lpaV2dnZMTEw6OjowMDAaGhoVFRX9/f3s7OzU1NTFxcW9vb2KiopYWFhTU1MtLS0nJyciIiINDQ3x8fHm5ubf39/Nzc2oqKibm5uNjY1eXl49PT0fHx/09PTp6enQ0NCzs7OsrKyYmJiRkZGHh4eBgYF+fn5vb29bW1tPT09GRkZDQ0NAQEA3NzcrKyscHBz6+vrj4+PW1tbKysq8vLyioqKVlZWEhIRsbGxnZ2dXV1dJSUnBwcGurq53d3cpKSkIPbx0AAAANHRSTlMATPHRp/m/fldEJxsL29XHw7iHXC4F+vjMophsRz8VEgf647q0q3hxYlP06ujk48WQOCIgda3aFAAAAqVJREFUOMuVlGV74kAURnFaWmiBurusyw0hhASCe3G3uvvWbeWPbzIkJLTwPLvnS+4kJ5ORNyP7b3omVsZUpq7JmU7CoHxRr/a/+E7xdyMmXVulS5nx/twAjsJ2cmhs6o3ROxqKW0Ek6pvrfq1o/HZoZW94otVR+S3wmopC1zKWUB7e4uqXKDP6e2iDu94l6SZjgXbsSToyPqBbPwAh1oXZ5oimFJsQ8Z4HLnDcV2IfUS6crQOJNTgzC85k2mpJ4TuPGLZzGEyA3ebzvGCEp2rb8Y4KjtkH64TruowR1E0gAxT2QDFYKu/MVj0awdE+AxTPCBtGEqEqu5RbKa7OBpmcY0RwTEfAYnc4YsUcICi2ptm5OpSCs5yEDoiO3N/J8TQXSDd71cFhVDKBkbsOzul401mqtVeoIZ0YY8VaW+dwXiaixcON9JW5sFruPKh1nZ2UxlDJoLuxS+Lk8DhoqwCn4mMyKQPDcSSFnU+1xLabK9ePNa3/lUqt+A0tWPzvDdLUTxue85+20SP6oHpwyxXW0ucKKUm96gR49onTxJntT6zR2v3QIyjd2QKvOLGSvQDuR4xfi+SC4PTt80qkjl1mydo6MPVGwDdCq3w3QTfvJAKbt9Fo2gVW2xb/NX0vcka9vFLCaPTBkBXwOCDCKbRj3z7SqLmWJO+5+VhyoU3YJ+MxKselQ8l1NB7g9qGYIZJF9npQp91BO4R3L2ykl3slY+ZGjJJKV64aE3MCHQSO/A06JY6MrGNwgUj63BmvYU9RyU/fh/a82Y64ho3zC1r54hAjnEXW9DK3V/oy3y5fGgdkiK99KX4VGc0Mijy5F2H38Nf53Ip4NmoVx1sRcHsV/Fvd/eoTX1q5NC2NwneTQe1XawbEE/WLyowMKVPyVfmg7B/5C0QS4X4FJcxWAAAAAElFTkSuQmCC" alt="avatar" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[高精度]]></title>
        <id>https://houpingze.github.io/gao-jing-du/</id>
        <link href="https://houpingze.github.io/gao-jing-du/">
        </link>
        <updated>2020-08-09T02:22:21.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://houpingze.github.io/post-images/1596939794090.png" alt="" loading="lazy"></figure>
<h1 id="使用高精度的步骤">使用高精度的步骤：</h1>
<ol>
<li>利用string进行读入</li>
<li>将string存入数组中，数字的低位放在数组的前面，高位放在数组后面</li>
<li>利用数组进行运算</li>
<li>输出结果</li>
<li><img src="https://houpingze.github.io/post-images/1596940661406.png" alt="" loading="lazy"><br>
代码如下：<pre><code class="language-cpp">    a[0]=x.size();
 for(int i=1;i&lt;=a[0];i++){
 	a[i]=x[a[0]-i]-'0';
 } 
 b[0]=y.size();
 for(int i=1;i&lt;=b[0];i++){
 	b[i]=y[b[0]-i]-'0';
 } 
 
</code></pre>
</li>
</ol>
<h2 id="代码">代码：</h2>
<h3 id="加">加</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
string x,y;
int a[10000],b[10000],c[100000];
int main(){
    cin&gt;&gt;x&gt;&gt;y;
    /* s1-&gt;a */
    /*低位放在下标少的*/
    a[0]=x.size();
    for(int i=1;i&lt;=a[0];i++){
    	a[i]=x[a[0]-i]-'0';
	} 
    b[0]=y.size();
    for(int i=1;i&lt;=b[0];i++){
    	b[i]=y[b[0]-i]-'0';
	} 
	int l=max(a[0],b[0]),len=0;
	for(int i=1;i&lt;=l;i++){
		c[i]+=a[i]+b[i];
		len=max(len,i);
		if(c[i]&gt;=10){
			c[i]-=10;
			c[i+1]++;
			len=i+1;
		}
	}
	for(int i=len;i&gt;=1;i--) cout&lt;&lt;c[i];
    return 0;
}
</code></pre>
<p>老师的代码（其实差不多）：<br>
<img src="https://houpingze.github.io/post-images/1596941687551.png" alt="" loading="lazy"></p>
<h3 id="减">减</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
string x,y;
int a[10000],b[10000],c[100000];
int main(){
    cin&gt;&gt;x&gt;&gt;y;
    a[0]=x.size(),b[0]=y.size();
    for(int i=1;i&lt;=a[0];i++) a[i]=x[a[0]-i]-'0'; 
    for(int i=1;i&lt;=b[0];i++) b[i]=y[b[0]-i]-'0'; 
	int l=max(a[0],b[0]),len=0;
	for(int i=1;i&lt;=l;i++){
		if(a[i]&lt;b[i]) a[i]+=10,a[i+1]--;
		c[i]=a[i]-b[i]; 
	}
	while(l&gt;0&amp;&amp;c[l]==0) l--;
	for(int i=l;i&gt;=1;i--) cout&lt;&lt;c[i];
    return 0;
}
</code></pre>
<p>课后测：<br>
<img src="https://houpingze.github.io/post-images/1596946748131.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[4507 补充]]></title>
        <id>https://houpingze.github.io/4507-bu-chong/</id>
        <link href="https://houpingze.github.io/4507-bu-chong/">
        </link>
        <updated>2020-08-08T03:41:36.000Z</updated>
        <content type="html"><![CDATA[<p>1.填表法<br>
2.刷表法</p>
<h1 id="刷表法">刷表法</h1>
<p>代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
int n,cnt,m,f[100][100],x,y;
int dir[4][5]{{-2,1},{2,1},{-1,2},{1,2}};
int main(){
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y;
    swap(n,m);
	f[0][0]=1;
	for(int j=0;j&lt;=n;j++){
		for(int i=0;i&lt;=m;i++){
			if(i==x||j==y){
				f[i][j]=0;
				continue;
			}
			for(int k=0;k&lt;4;k++){
				int nx=i+dir[k][0],ny=j+dir[k][1];
				if(nx&gt;=0&amp;&amp;nx&lt;=m&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;=n) f[nx][ny]+=f[i][j];
			}
		} 
	}
	cout&lt;&lt;f[m][n];
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[其他递推]]></title>
        <id>https://houpingze.github.io/qi-ta-di-tui/</id>
        <link href="https://houpingze.github.io/qi-ta-di-tui/">
        </link>
        <updated>2020-08-08T02:46:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="4514">4514</h2>
<p><img src="https://houpingze.github.io/post-images/1596855149009.png" alt="" loading="lazy"><br>
f[i]表示i个椭圆最多可以把平面分成f[i]个地盘<br>
<em><em>递推式：f[i]=f[i-1]+2</em>(i-1)(其中i-1表示前i-1个椭圆，2表示第i个椭圆会和每个椭圆相交2次，每相交一次会产生1个新的地盘)</em>*<br>
边界：f[1]=2<br>
解：f[n]<br>
代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
typedef unsigned long long ull;
using namespace std;
int n,cnt,m;
int main(){
	cin&gt;&gt;n;
	int f[26];
	f[1]=2;
	for(int i=2;i&lt;=n;i++){
		f[i]=f[i-1]+2*(i-1);
	} 
	cout&lt;&lt;f[n];
}
</code></pre>
<h2 id="4515">4515</h2>
<p>小P最近搬进了新家，打算布置一番。现在小P有n本不同的书，想放进带有m个格子的书架上（m&lt;n）。要求每个格子至少有一本书。请你帮小P计算有多少种布置的方案。</p>
<p>定义：f[i][j]表示前i本书放入j个格子的方案总数,（每个格子至少放1本书）<br>
递推式：f[i][j]=f[i-1][j]*j+f[i-1][j-1]<br>
边界：f[1][1]=1;<br>
解：f[n][m]</p>
<p>代码：</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
typedef unsigned long long ull;
using namespace std;
int n,cnt,m,f[100][100];
int main(){
	cin&gt;&gt;n&gt;&gt;m;
	f[1][1]=1;
	for(int i=1;i&lt;=n;i++){
		for(int j=1;j&lt;=m;j++){
			if(i==1&amp;&amp;j==1) continue;
			f[i][j]=f[i-1][j]*j+f[i-1][j-1];
		}
	}
	cout&lt;&lt;f[n][m];
}

</code></pre>
<p>课后测：<br>
<img src="https://houpingze.github.io/post-images/1596860600158.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
</feed>